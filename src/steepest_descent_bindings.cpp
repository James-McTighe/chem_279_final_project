#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include <armadillo>
#include <iomanip>
#include <fstream>
#include "basis_functions/atom.hpp"
#include "basis_functions/gaussian.hpp"
#include "basis_functions/basis.hpp"
#include "fock.hpp"

namespace py = pybind11;


double calculate_total_energy(std::vector<Atom>& atoms, 
                              std::vector<ContractedGaussian>& basis_set,
                              int num_alpha_electrons, 
                              int num_beta_electrons,
                              const SCFState* guess = nullptr);

std::pair<arma::vec, SCFState> calculate_gradient(std::vector<Atom>& atoms, 
                                                  int n_alpha, int n_beta);

void steepest_descent_optimization(std::vector<Atom>& atoms,
                                   std::vector<ContractedGaussian>& basis_set,
                                   int num_alpha_electrons,
                                   int num_beta_electrons,
                                   double gradient_tol,
                                   int max_iterations,
                                   const std::string& output_path,
                                   bool logging);


py::array_t<double> arma_vec_to_numpy_mat(const arma::vec& vec, int num_atoms) {
    // Reshapes the flat gradient vector into a 3xN NumPy array
    py::array_t<double> result({3, num_atoms});
    auto buf = result.request();
    double *ptr = static_cast<double*>(buf.ptr);
    
    for (int i = 0; i < 3 * num_atoms; i++) {
        ptr[i] = vec(i);
    }
    return result;
}


class SteepestDescentOptimizer {
private:
    std::vector<Atom> atoms_;
    std::vector<ContractedGaussian> basis_set_;
    int num_alpha_electrons_;
    int num_beta_electrons_;
    
public:
    SteepestDescentOptimizer(const std::string& atoms_file_path,
                            int num_alpha_electrons,
                            int num_beta_electrons)
        : num_alpha_electrons_(num_alpha_electrons),
          num_beta_electrons_(num_beta_electrons)
    {
        atoms_ = parse_file(atoms_file_path);
        basis_set_ = make_sto3g_basis_from_xyz(atoms_);
    }
    
    void set_geometry(py::list atom_data) {
        atoms_.clear();
        for (auto item : atom_data) {
            auto atom_tuple = item.cast<py::tuple>();
            int z_num = atom_tuple[0].cast<int>();
            double x = atom_tuple[1].cast<double>();
            double y = atom_tuple[2].cast<double>();
            double z = atom_tuple[3].cast<double>();
            
            Atom atom;
            atom.z_num = z_num;
            atom.pos = arma::vec3({x, y, z});
            atoms_.push_back(atom);
        }
        basis_set_ = make_sto3g_basis_from_xyz(atoms_);
    }
    
    py::list get_geometry() {
        py::list result;
        for (const auto& atom : atoms_) {
            result.append(py::make_tuple(atom.z_num, atom.pos[0], atom.pos[1], atom.pos[2]));
        }
        return result;
    }
    
    double calculate_energy() {
        return calculate_total_energy(atoms_, basis_set_, num_alpha_electrons_, num_beta_electrons_, nullptr);
    }
    
    py::array_t<double> calculate_gradient_numpy() {
        auto result = calculate_gradient(atoms_, num_alpha_electrons_, num_beta_electrons_);
        return arma_vec_to_numpy_mat(result.first, atoms_.size());
    }
    
    void optimize(double gradient_tol = 1e-4, int max_iterations = 100, 
                  const std::string& output_path = "", bool logging = false) {
        steepest_descent_optimization(atoms_, basis_set_, num_alpha_electrons_, 
                                     num_beta_electrons_, gradient_tol, 
                                     max_iterations, output_path, logging);
    }

    void save_geometry(const std::string& filename) {
        std::ofstream outfile(filename);
        if (!outfile.is_open()) throw std::runtime_error("Could not open file for writing.");
        outfile << atoms_.size() << "\nGenerated by SteepestDescentOptimizer\n";
        for (const auto& atom : atoms_) {
            outfile << atom.z_num << " " << std::fixed << std::setprecision(8)
                    << atom.pos[0] << " " << atom.pos[1] << " " << atom.pos[2] << "\n";
        }
    }

    int num_atoms() const { return static_cast<int>(atoms_.size()); }
};


PYBIND11_MODULE(steepest_descent_py, m) {
    m.doc() = R"pbdoc(
        Molecular Geometry Optimization via Steepest Descent
        ----------------------------------------------------
        A Python interface for a C++ unrestricted Hartree-Fock (UHF) 
        geometry optimizer using the STO-3G basis set.
    )pbdoc";

    py::class_<SteepestDescentOptimizer>(m, "SteepestDescentOptimizer", R"pbdoc(
        Main optimizer class for managing molecular state and gradients.
    )pbdoc")
        .def(py::init<const std::string&, int, int>(),
             py::arg("atoms_file_path"),
             py::arg("num_alpha_electrons"),
             py::arg("num_beta_electrons"),
             "Initializes the optimizer from an XYZ file.")

        .def("set_geometry", &SteepestDescentOptimizer::set_geometry,
             py::arg("atom_data"),
             "Update geometry. Input: list of tuples (Z, x, y, z) in Bohr.")

        .def("get_geometry", &SteepestDescentOptimizer::get_geometry,
             "Returns the current geometry as a list of (Z, x, y, z) tuples.")

        .def("calculate_energy", &SteepestDescentOptimizer::calculate_energy,
             "Performs a UHF calculation and returns total energy in Hartrees.")

        .def("calculate_gradient", &SteepestDescentOptimizer::calculate_gradient_numpy,
             "Calculates and returns the energy gradient as a 3xN NumPy array.")

        .def("optimize", &SteepestDescentOptimizer::optimize,
             py::arg("gradient_tol") = 1e-4,
             py::arg("max_iterations") = 100,
             py::arg("output_path") = "",
             py::arg("logging") = false,
             "Runs the steepest descent optimization with line search.")

        .def("save_geometry", &SteepestDescentOptimizer::save_geometry,
             py::arg("filename"),
             "Saves the current atomic positions to an XYZ file.")

        .def("num_atoms", &SteepestDescentOptimizer::num_atoms,
             "Returns the number of atoms in the system.")

        .def("__repr__", [](const SteepestDescentOptimizer &opt) {
            return "<SteepestDescentOptimizer: " + std::to_string(opt.num_atoms()) + " atoms>";
        });
}